单一职责原则：接口定义同一功能的方法。
里氏替换原则：继承父类的所有属性和方法，有父类的地方都可以被子类替换
	（在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类方法）


依赖倒置原则：所有的类的依赖关系通过接口或抽象类进行关联(通过实现接口进行关系绑定)(通过构造函数传入，通过方法传参，解耦合关系）
实现方式：1.通过构造器，2.通过接口传递实现依赖

接口隔离原则：所有接口定义的方法应都被使用。接口要尽量小

迪米特法则（也叫最小知道原则）：一个类应该对自己的耦合或调用的类知道的越少越好(朋友类的定义是
这样的:出现在成员变量、方法的输入输出参数中的类称为成员朋友类) 核心观念是类间解耦， 弱耦合

开闭原则：对扩展开放（提供方扩展，对修改关闭（使用方）。（尽量减少对原有代码的修改，保持代码的纯洁性和稳定性）

UML:

依赖：  虚线箭头， 依赖即一个类的实现需要其他类的协助，通常代码表现为方法参数，局部变量，静态方法调用，util类调用，uml中使用一条箭头的虚线，从依赖方指向被依赖的类

泛化： 继承关系  依赖关系的特例   实线空心三角箭头

实现：  a类实现b类 ，依赖关系的特例。 虚线空心三角箭头

关联：类与类之间的联系， 依赖关系的特例 关联具有导向性， 即双向关系或单向关系    实线箭头表示

聚合： 表示整体与部分的关系 关联关系的特例。具有关联关系的导航行与多重性。如 一台电脑由键盘，鼠标，显示器组成。用实线 带空心菱形箭头表示

组合关系： 表示整体与部分的关系， 整体与部分不可分离 如人 , 手，脚，头。  用实线 带实心菱形箭头表示。 new Head()


创建型模式

结构型模式

行为型模式



抽象工厂模式：创建工厂的工厂

单例模式：进程调用过程中，保证只创建一次。
工厂模式：给我什么材料，我就造什么东西

模版方法模式：子类中所共用的类，提取到父类当中


代理模式：送花，个人送及代送

原型模式：通过复制（clone)产生多类（降低内存消耗）

中介者模式：通过中介完成各个模块之间的调用（降低耦合度）(多个对象之间存在依赖关系)

数据对象映射：将对象和数据存储映射起来，对一个对象的操作会映射为对数据存储的操作。

观察者模式：当一个对象状态发生改变时，依赖他的对象全部会收到通知，并自动更新。（实现了低耦合，非侵入式的通知和更新机制)

原型模式：与工厂模式作用相似，都是用来创建对象。与工厂模式不同，原型模式是先创建好一个原型对象，然后通过clone原型对象来创建新对象，这样就免去了类创建时重复的初始化操作。适用于大对象的创建，创建大对象需要很大的开销，原型模式仅需要内存拷贝即可。

装饰器模式：可以动态的添加修改类的功能。

迭代器模式：在不需要了解内部实现的前提下，遍历一个聚合对象的内部元素。相对于传统的编程模式，迭代器模式可以隐藏遍历元素所需的操作。

代理模式：在客户端与实体之间建立一个代理对象，客户端对实体进行操作全部委派给代理对象，隐藏实体的具体实现细节。proxy还可以与业务代码分离，部署到另外的服务器，业务代码中通过RPC来委派任务。


外观模式：为子系统的一组接口提供一个统一的界面，此模式定义了一个高层的接口，这一个高层的接口使得子系统更加容易使用（数据视图模式）

组合模式：将对象组合成树形结构以表示"部分-整体"的层次结构
组合模式能让用户以一致的方式处理个别对象以及组合对象。

策略模式：定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换；会员优惠政策

模版方法模式：定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构可以定义该算法的某些特定步骤 案例：模版继承，模版钩子

责任链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这个对象连城一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。案例：学生请加


适配器模式：将截然不同的接口，封装成统一的api。

策略模式：将一组特定的行为和算法封装成类，以适应某些特定的上下文环境。策略模式可实现依赖倒置和控制反转。











