
类与类通过方法，构造器来进行关联。








简单工厂模式： 违反opc(开闭原则） 给类增加新功能时，尽量不修改代码，或者少修改代码

工厂模式：

抽象工厂模式：提供一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

原型模式：克隆对象，减小io操作，减少开销。

适配器模式：对不同的项目接口进行关联；本来对象方法只能处理一种请求，如果仍需要处理其他请求，则通过适配器进行关联绑定。（该案例不够准确）（mp3,mp4,mp5播放）
（接口适配器，对象适配器）



建造者模式：将实例话较复杂的类封装起来，通过建造器类进行构造。通过构建器建造较复杂的对象

桥接模式：是用于把抽象化与实现化解耦，使得二者可以独立变化。（画不同颜色的形状）

过滤器模式：这种模式允许开发人员使用不同的标准来过滤一组对象。

组合模式：又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

装饰器模式（Decorator Pattern）:允许向一个现有的对象添加新的功能，同时又不改变其结构;动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。在不改变原有的基础上添加功能。



观察者模式（发布-订阅模式）：定义了一种一对多的依赖关系，让多个观察者对象监听某一主题对象，这一对象在状态发生变化时，会通知其他所有观察者对象。


状态模式：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像改变了其类。将不同状态的行为分割开来。


外观模式：隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。

享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。将创建的对象放入数组中

在代理模式（Proxy Pattern）中，为其他对象提供一种代理以控制对这个对象的访问。//送花

责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。

命令模式（Command Pattern）是一种数据驱动的设计模式。将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。 //客户让服务员点单

解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。//将类引入到解释器当中解释出不同的结果

迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。//

中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。//

备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。//用一个类承载另一个类修改前的数据

当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。

策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改

模板模式（Template Pattern），一个抽象类公开定义了执行它的方法的方式/模板。

访问者模式（Visitor Pattern），我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。